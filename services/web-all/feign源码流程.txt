0、SpringBoot项目启动：
    1、自动扫描所有组件。feign组件。扫描所有标注了@FeignClient注解的接口
    2、把每个接口每个方法都保存在了Map中；每个方法都对应一个执行这个方法的  处理器
        Map<Method,MethodHandler> dispatch;每个处理器都是：SynchronousMethodHandler


1、cartFeignClient,addToCart(skuId，skuNum); cartFeignClient在容器中是一个代理对象
    1)、每个feign客户端都是 ReflectiveFeign。且是一个 InvocationHandler。
    2)、进入到InvocationHandler的invoke方法进行拦截
        1、第一次进行远程调用的时候，从dispatch的map中拿到这个方法对应的处理器
        2、SynchronousMethodHandler来执行远程调用   smh.invoke
        // AQS:抽象队列服务器
        ==========远程调用流程=============
        1、根据方法的参数创建一个【请求模板】{直接创建一个新的模板，给里面放东西，新模板里面什么都没有}[feign接口声明的所有信息保存到了模板中]
        接口的所有信息封装好，new一个模板
        2、【请求设置】(默认)[请求超时时间...]
        3、【重试器】Retryer：
        4、【远程调用】：executeAndDecode
            4.1、准备一个请求
            4.2、客户端执行
                ......
                LoadBalancerFeignClient去帮我们发起远程调用
                FeignLoadBalancer
                ...URL.openConnection.  out.write
            4.3、解码响应数据为方法的返回值类型


面试题：
    1、如果nacos炸了，远程调用还能不能执行？
        只要调用过，会有缓存，炸了也没事


远程调用逻辑：
public Object invoke(Object[] argv) throws Throwable {
        RequestTemplate template = this.buildTemplateFromArgs.create(argv);
        Request.Options options = this.findOptions(argv);
        Retryer retryer = this.retryer.clone();

        while(true) {
            try {
                  //executeAndDecode：执行并解码，如果远程成功，while直接退出
                  //如果远程炸了
                return this.executeAndDecode(template, options);
            } catch (RetryableException var9) {
                RetryableException e = var9;

                try {
                    //炸了，调用continueOrPropagate方法，如果依旧存在异常，则将异常抛出
                    retryer.continueOrPropagate(e);//重试器如果抛异常，就不重试，不抛异常就继续
                } catch (RetryableException var8) {
                    Throwable cause = var8.getCause();
                    if (this.propagationPolicy == ExceptionPropagationPolicy.UNWRAP && cause != null) {
                        throw cause;
                    }

                    throw var8;
                }

                if (this.logLevel != Level.NONE) {
                    this.logger.logRetry(this.metadata.configKey(), this.logLevel);
                }
            }
            continue;//?
        }
    }